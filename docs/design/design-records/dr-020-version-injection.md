# DR-020: Binary Version Injection Strategy

- Date: 2025-01-06
- Status: Accepted
- Category: Build & Distribution

## Problem

Binary versioning needs a mechanism to embed version information at build time. The system must:

- Provide version information to users via `start --version`
- Support semantic versioning (v1.2.3)
- Include build metadata (commit SHA, build date, Go version)
- Work with multiple build tools (make, goreleaser, go install)
- Support both release builds (tagged versions) and development builds
- Avoid runtime dependencies or external files
- Enable reproducible builds (version encoded in binary)
- Work in `start doctor` for diagnostics
- Follow Go ecosystem conventions
- Allow development builds without special setup

## Decision

Use Go's `-ldflags` at build time to inject version information into a dedicated `internal/version` package variable.

Version sources:
- Git tags for production releases (semantic versioning)
- Git describe for post-release commits
- Default "dev" for development builds without ldflags

## Why

Zero runtime dependencies:

- No version files to read at runtime
- No network calls to check versions
- Version embedded directly in binary
- Works offline, always available

Standard Go practice:

- Widely used across Go ecosystem
- Well-documented pattern
- Supported by all major build tools
- Familiar to Go developers

Single source of truth:

- Git tags define version (no separate version files)
- Build process extracts from Git
- No manual version updates in code
- Version and commit always in sync

Build tool agnostic:

- Works with make, goreleaser, mise, task, etc.
- Standard ldflags mechanism
- Can be integrated into any build pipeline
- Simple to understand and maintain

Reproducible builds:

- Version encoded at build time
- Binary contains complete build metadata
- Can verify version without external dependencies
- Useful for debugging and support

Development-friendly:

- Works without ldflags (defaults to "dev")
- `go run` works immediately
- No special setup for development
- Clear distinction between dev and release builds

## Trade-offs

Accept:

- Requires Git during build (standard for Go projects)
- Cannot change version without rebuild (expected immutability)
- Slightly longer build commands (mitigated by Makefile/build scripts)
- Version information duplicated in binary (small size cost)

Gain:

- Zero runtime dependencies or file reads
- Immutable and verifiable version information
- Works seamlessly with all build tools
- Simple to implement and maintain
- Supports both release and development builds
- Standard Go ecosystem pattern

## Alternatives

Version file in binary directory:

```
start/
├── start (binary)
└── VERSION
```

- Pro: Easy to update without rebuild
- Pro: No build-time injection needed
- Con: Runtime file dependency (must exist and be readable)
- Con: Can become out of sync with binary
- Con: Deployment complexity (two files to distribute)
- Con: Breaks if file missing or moved
- Rejected: Runtime dependency unacceptable

Embedded version file in binary:

```go
//go:embed VERSION
var version string
```

- Pro: Single file deployment
- Pro: No ldflags needed
- Con: Still need to update VERSION file manually
- Con: Not tied to Git tags (manual process)
- Con: Easy to forget updating VERSION
- Con: No commit SHA or build metadata
- Rejected: Manual version management error-prone

Environment variable at runtime:

```bash
START_VERSION=1.2.3 start --version
```

- Pro: Version can change without rebuild
- Pro: Simple implementation
- Con: User must set environment variable
- Con: Version not verifiable (can be anything)
- Con: Different users see different versions
- Con: Not suitable for distributed binaries
- Rejected: Too unreliable and inconsistent

Build-time generated file:

```go
// Generated by build script
package version
const Version = "1.2.3"
```

- Pro: Version in code (somewhat visible)
- Pro: No ldflags needed
- Con: Generated file in source tree (git noise)
- Con: Still need build step to generate
- Con: Can accidentally commit stale generated file
- Con: Not standard Go practice
- Rejected: Ldflags approach cleaner

Package version from go.mod:

```go
import "runtime/debug"
info := debug.ReadBuildInfo()
```

- Pro: Automatic from Go module system
- Pro: No ldflags needed
- Con: Only works for `go install` with modules
- Con: No control over version format
- Con: No build metadata (commit, date)
- Con: Doesn't work for `go build` or make
- Rejected: Limited flexibility and control

## Structure

Version package:

Location: `internal/version/version.go`

```go
package version

// Injected at build time via -ldflags
var (
    Version   = "dev"           // Semantic version (e.g., "1.2.3")
    Commit    = "unknown"       // Git commit SHA (short, 7 chars)
    BuildDate = "unknown"       // ISO 8601 timestamp
    GoVersion = "unknown"       // Go compiler version
)

// Full returns a complete version string
func Full() string {
    return fmt.Sprintf("%s (commit: %s, built: %s, go: %s)",
        Version, Commit, BuildDate, GoVersion)
}

// Short returns just the semantic version
func Short() string {
    return Version
}
```

Build command:

```bash
go build -ldflags "\
  -X 'github.com/grantcarthew/start/internal/version.Version=$(git describe --tags --always --dirty)' \
  -X 'github.com/grantcarthew/start/internal/version.Commit=$(git rev-parse --short HEAD)' \
  -X 'github.com/grantcarthew/start/internal/version.BuildDate=$(date -u +%Y-%m-%dT%H:%M:%SZ)' \
  -X 'github.com/grantcarthew/start/internal/version.GoVersion=$(go version | awk '{print $3}')' \
" -o start ./cmd/start
```

Makefile integration:

```makefile
VERSION := $(shell git describe --tags --always --dirty)
COMMIT := $(shell git rev-parse --short HEAD)
BUILD_DATE := $(shell date -u +%Y-%m-%dT%H:%M:%SZ)
GO_VERSION := $(shell go version | awk '{print $$3}')

LDFLAGS := -X 'github.com/grantcarthew/start/internal/version.Version=$(VERSION)' \
           -X 'github.com/grantcarthew/start/internal/version.Commit=$(COMMIT)' \
           -X 'github.com/grantcarthew/start/internal/version.BuildDate=$(BUILD_DATE)' \
           -X 'github.com/grantcarthew/start/internal/version.GoVersion=$(GO_VERSION)'

build:
	go build -ldflags "$(LDFLAGS)" -o start ./cmd/start

install:
	go install -ldflags "$(LDFLAGS)" ./cmd/start
```

GoReleaser integration:

```yaml
# .goreleaser.yaml
builds:
  - main: ./cmd/start
    binary: start
    ldflags:
      - -s -w
      - -X github.com/grantcarthew/start/internal/version.Version={{.Version}}
      - -X github.com/grantcarthew/start/internal/version.Commit={{.ShortCommit}}
      - -X github.com/grantcarthew/start/internal/version.BuildDate={{.Date}}
      - -X github.com/grantcarthew/start/internal/version.GoVersion={{.Env.GOVERSION}}
```

## Version Sources

Git tags (production releases):

- Format: Semantic versioning (v1.2.3)
- Command: `git describe --tags --always --dirty`
- Examples:
  - Clean tagged release: `v1.2.3`
  - Post-release commit: `v1.2.3-5-gabc1234`
  - Uncommitted changes: `v1.2.3-dirty`
  - No tags yet: `abc1234` (commit SHA)

Development builds:

Default values when built without ldflags:
- `Version = "dev"`
- `Commit = "unknown"`
- `BuildDate = "unknown"`
- `GoVersion = "unknown"`

This allows:
```bash
go run ./cmd/start --version
# Output: start dev (commit: unknown, built: unknown, go: unknown)
```

## Usage Examples

Version flag output:

```bash
$ start --version
start 1.2.3 (commit: abc1234, built: 2025-01-06T10:30:00Z, go: go1.22.0)

$ start version
start 1.2.3 (commit: abc1234, built: 2025-01-06T10:30:00Z, go: go1.22.0)
```

Doctor command output:

```bash
$ start doctor
Version Information:
  CLI Version:     1.2.3
  Commit:          abc1234
  Build Date:      2025-01-06T10:30:00Z
  Go Version:      go1.22.0

Asset Information:
  Asset Cache:     ~/.config/start/assets/
  Cached Assets:   12 tasks, 8 roles, 4 agents
```

Version command implementation:

```go
// Global flag
rootCmd.Version = version.Full()
rootCmd.SetVersionTemplate("{{.Version}}\n")

// Explicit subcommand (for consistency with other commands)
var versionCmd = &cobra.Command{
    Use:   "version",
    Short: "Show version information",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println(version.Full())
    },
}
```

## Implementation Notes

Package design:

The `internal/version` package should be minimal:
- No external dependencies
- Pure data plus simple formatters
- Used by `cmd/start/main.go` for `--version` flag
- Used by `cmd/start/doctor.go` for version reporting

Build integration checklist:

- Create `internal/version/version.go`
- Add Makefile with version injection
- Configure goreleaser with ldflags
- Add `start version` subcommand
- Add `--version` global flag
- Include version in `start doctor` output
- Document build process in README
